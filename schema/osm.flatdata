/// OSM data types and archive

namespace osm {

// Max 40 bits value used to indicate null references.
/**
 * Special value which represents an invalid index.
 */
const u64 INVALID_IDX = 0xFFFFFFFFFF;

/**
 * Metadata attached to the archive.
 */
struct Header {
    /**
     * All coordinates in this archive are scaled by this constant
     * To get the original degree-based coordinate back compute (latitude/coord_scale,longitude/coord_scale)
     */
    coord_scale: i32;

    /// Bounding box (min longitude scaled with `header.coord_scale`)
    bbox_left: i32 : 32;
    /// Bounding box (max longitude scaled with `header.coord_scale`)
    bbox_right: i32 : 32;
    /// Bounding box (max latitude scaled with `header.coord_scale`)
    bbox_top: i32 : 32;
    /// Bounding box (min latitude scaled with `header.coord_scale`)
    bbox_bottom: i32 : 32;

    /// Writing program used to write the data (reference to `stringtable`).
    writingprogram_idx: u64 : 40;
    /// The origin (source) of the data.
    source_idx: u64 : 40;

    /**
     * Replication timestamp, expressed in seconds since the epoch.
     * See [`state.txt`].
     *
     * [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
     */
    replication_timestamp: i64 : 64;
    /**
     * Replication sequence number (`sequenceNumber` from [`state.txt`]).
     *
     * [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
     */
    replication_sequence_number: i64 : 64;
    /**
     * Replication base URL (reference to `stringtable`).
     */
    replication_base_url_idx: u64 : 40;
}

/**
 * A `(key, value)` attached to a `Node`, `Way`, or `Relation.
 */
struct Tag {
    /// Key index in `stringtable`
    key_idx: u64 : 40;
    /// Value index in `stringtable`
    value_idx: u64 : 40;
}

/**
 * A node is one of the core elements in the OpenStreetMap data model.
 *
 * It consists of a single point in space defined by its latitude, longitude and node id.
 *
 * See <https://wiki.openstreetmap.org/wiki/Node>.
 */
struct Node {

    osm_id: i64: 40;

    /// Latitude (scaled with `header.coord_scale`).
    lat: i32 : 32;
    /// Longitude (scaled with `header.coord_scale`).
    lon: i32 : 32;
    /**
     * Range of tags attached to this node.
     *
     * The values of the range are indexes in the `tags_index` vector.
     */
    @range(tags)
    tag_first_idx: u64 : 40;
}

/**
 * Index of a node.
 */
struct NodeIndex {
    /// Index in the `nodes` vector.
    @optional(INVALID_IDX)
    value: u64 : 40;
}

struct HilbertNodePair {
    i: u64 : 40;
    h: u64 : 64;
}

/**
 * A way is an ordered list of nodes.
 *
 * See <https://wiki.openstreetmap.org/wiki/Way>.
 */
struct Way {

    osm_id: i64: 40;

    /**
     * Range of tags attached to this node.
     *
     * The values of the range are indexes in the `tags_index` vector.
     */
    @range(tags)
    tag_first_idx: u64 : 40;
    /**
     * Range of nodes this way consists of.
     *
     * The values of the range are indexes in the `nodes_index` vector.
     */
    @range(refs)
    ref_first_idx: u64 : 40;
}

struct HilbertWayPair {
    i: u32 : 32;
    /// PointOnSurface Hilbert location of way.
    h: u64 : 64;
}

/**
 * Index of a tag.
 */
struct TagIndex {
    /// Index in the `tags` vector.
    value: u64 : 40;
}

struct Member {
    /// Index of the member in either the `relations`, `ways`, or `nodes` vector.
    @optional(INVALID_IDX)
    idx: u64: 40;

    // Index in `stringtable`
    role_idx: u64 : 40;

    entity_type: EntityType;
}

enum EntityType : u8 : 2 {
    Node = 0,
    Way = 1,
    Relation = 2,
}

/**
 * A relation is an ordered list of one or more nodes, ways and/or relations as members.
 *
 * See <https://wiki.openstreetmap.org/wiki/Relation>.
 */
struct Relation {

    osm_id: i64: 40;

    // PointOnSurface Hilbert location of relation.
    h: u64: 64;

    /**
     * Range of tags attached to this relation.
     *
     * The values of the range are indexes in the `tags` vector.
     */
    @range(tags)
    tag_first_idx: u64 : 40;

    @range(members)
    member_first_idx: u32: 32;
}

struct HilbertRelationPair {
    i: u32 : 32;
    h: u64 : 64;
}

archive Osm {
    /**
     * Header which contains the metadata attached to the archive.
     */
    @explicit_reference( Header.writingprogram_idx, stringtable )
    @explicit_reference( Header.source_idx, stringtable )
    @explicit_reference( Header.replication_base_url_idx, stringtable )
    header: Header;

    /**
     * List of nodes.
     *
     * A node references a range of tags in the `tags_index` vector.
     */
    @explicit_reference( Node.tag_first_idx, tags_index )
    nodes: vector<Node>;

    @optional
    hilbert_node_pairs: vector<HilbertNodePair>;

    /**
     * List of ways.
     *
     * A way references
     *
     * * a range of tags in the `tags_index` vector, and
     * * a range of nodes in the `nodes_index` vector.
     */
    @explicit_reference( Way.tag_first_idx, tags_index )
    @explicit_reference( Way.ref_first_idx, nodes_index )
    ways: vector<Way>;

    @optional
    hilbert_way_pairs_not_used: vector<HilbertWayPair>;

    @explicit_reference( Relation.tag_first_idx, tags_index )
    @explicit_reference( Relation.member_first_idx, members )
    relations: vector<Relation>;

    @optional
    hilbert_relation_pairs_not_used: vector<HilbertRelationPair>;

    members: vector<Member>;

    /**
     * List of tags.
     *
     * A tag references its key and value in the `stringtable` raw data.
     */
    @explicit_reference( Tag.key_idx, stringtable )
    @explicit_reference( Tag.value_idx, stringtable )
    tags: vector<Tag>;

    /**
     * Auxiliary index of tags to model 1:n relationships between nodes, ways, relations
     * and tags.
     */
    @explicit_reference( TagIndex.value, tags )
    tags_index: vector<TagIndex>;

    /**
     * Auxiliary index of nodes to model 1:n relationship between ways and nodes.
     */
    @explicit_reference( NodeIndex.value, nodes )
    nodes_index: vector<NodeIndex>;

    /**
     * List of strings separated by `\0`.
     */
    stringtable: raw_data;
}
} // namespace osm
