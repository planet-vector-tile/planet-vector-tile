// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PVTVALUE_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PVTVALUE_TYPE: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PVTVALUE_TYPE: [PVTValueType; 3] = [
    PVTValueType::String,
    PVTValueType::Number,
    PVTValueType::Boolean,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PVTValueType(pub u8);
#[allow(non_upper_case_globals)]
impl PVTValueType {
    pub const String: Self = Self(0);
    pub const Number: Self = Self(1);
    pub const Boolean: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::String, Self::Number, Self::Boolean];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::String => Some("String"),
            Self::Number => Some("Number"),
            Self::Boolean => Some("Boolean"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for PVTValueType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PVTValueType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for PVTValueType {
    type Output = PVTValueType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PVTValueType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PVTValueType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PVTValueType {}
// struct PVTTilePoint, aligned to 2
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct PVTTilePoint(pub [u8; 4]);
impl Default for PVTTilePoint {
    fn default() -> Self {
        Self([0; 4])
    }
}
impl core::fmt::Debug for PVTTilePoint {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PVTTilePoint")
            .field("x", &self.x())
            .field("y", &self.y())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PVTTilePoint {}
impl<'a> flatbuffers::Follow<'a> for PVTTilePoint {
    type Inner = &'a PVTTilePoint;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a PVTTilePoint>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a PVTTilePoint {
    type Inner = &'a PVTTilePoint;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<PVTTilePoint>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for PVTTilePoint {
    type Output = PVTTilePoint;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src =
            ::core::slice::from_raw_parts(self as *const PVTTilePoint as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for PVTTilePoint {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> PVTTilePoint {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: i16, y: i16) -> Self {
        let mut s = Self([0; 4]);
        s.set_x(x);
        s.set_y(y);
        s
    }

    pub fn x(&self) -> i16 {
        let mut mem = core::mem::MaybeUninit::<<i16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: i16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<i16 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> i16 {
        let mut mem = core::mem::MaybeUninit::<<i16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[2..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: i16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[2..].as_mut_ptr(),
                core::mem::size_of::<<i16 as EndianScalar>::Scalar>(),
            );
        }
    }
}

// struct PVTValue, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct PVTValue(pub [u8; 16]);
impl Default for PVTValue {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl core::fmt::Debug for PVTValue {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PVTValue")
            .field("t", &self.t())
            .field("v", &self.v())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PVTValue {}
impl<'a> flatbuffers::Follow<'a> for PVTValue {
    type Inner = &'a PVTValue;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a PVTValue>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a PVTValue {
    type Inner = &'a PVTValue;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<PVTValue>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for PVTValue {
    type Output = PVTValue;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const PVTValue as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for PVTValue {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> PVTValue {
    #[allow(clippy::too_many_arguments)]
    pub fn new(t: PVTValueType, v: f64) -> Self {
        let mut s = Self([0; 16]);
        s.set_t(t);
        s.set_v(v);
        s
    }

    pub fn t(&self) -> PVTValueType {
        let mut mem = core::mem::MaybeUninit::<<PVTValueType as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<PVTValueType as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_t(&mut self, x: PVTValueType) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<PVTValueType as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn v(&self) -> f64 {
        let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_v(&mut self, x: f64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum PVTTileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PVTTile<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PVTTile<'a> {
    type Inner = PVTTile<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PVTTile<'a> {
    pub const VT_LAYERS: flatbuffers::VOffsetT = 4;
    pub const VT_STRINGS: flatbuffers::VOffsetT = 6;
    pub const VT_VALUES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PVTTile { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PVTTileArgs<'args>,
    ) -> flatbuffers::WIPOffset<PVTTile<'bldr>> {
        let mut builder = PVTTileBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        if let Some(x) = args.strings {
            builder.add_strings(x);
        }
        if let Some(x) = args.layers {
            builder.add_layers(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn layers(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTLayer<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTLayer>>,
            >>(PVTTile::VT_LAYERS, None)
        }
    }
    #[inline]
    pub fn strings(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(PVTTile::VT_STRINGS, None)
        }
    }
    #[inline]
    pub fn values(&self) -> Option<flatbuffers::Vector<'a, PVTValue>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, PVTValue>>>(
                    PVTTile::VT_VALUES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for PVTTile<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PVTLayer>>,
            >>("layers", Self::VT_LAYERS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("strings", Self::VT_STRINGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, PVTValue>>>(
                "values",
                Self::VT_VALUES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct PVTTileArgs<'a> {
    pub layers: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTLayer<'a>>>>,
    >,
    pub strings: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, PVTValue>>>,
}
impl<'a> Default for PVTTileArgs<'a> {
    #[inline]
    fn default() -> Self {
        PVTTileArgs {
            layers: None,
            strings: None,
            values: None,
        }
    }
}

pub struct PVTTileBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PVTTileBuilder<'a, 'b> {
    #[inline]
    pub fn add_layers(
        &mut self,
        layers: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PVTLayer<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PVTTile::VT_LAYERS, layers);
    }
    #[inline]
    pub fn add_strings(
        &mut self,
        strings: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PVTTile::VT_STRINGS, strings);
    }
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, PVTValue>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PVTTile::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PVTTileBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PVTTileBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PVTTile<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PVTTile<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PVTTile");
        ds.field("layers", &self.layers());
        ds.field("strings", &self.strings());
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum PVTLayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PVTLayer<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PVTLayer<'a> {
    type Inner = PVTLayer<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PVTLayer<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_FEATURES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PVTLayer { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PVTLayerArgs<'args>,
    ) -> flatbuffers::WIPOffset<PVTLayer<'bldr>> {
        let mut builder = PVTLayerBuilder::new(_fbb);
        if let Some(x) = args.features {
            builder.add_features(x);
        }
        builder.add_name(args.name);
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(PVTLayer::VT_NAME, Some(0)).unwrap() }
    }
    #[inline]
    pub fn features(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTFeature<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTFeature>>,
            >>(PVTLayer::VT_FEATURES, None)
        }
    }
}

impl flatbuffers::Verifiable for PVTLayer<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PVTFeature>>,
            >>("features", Self::VT_FEATURES, false)?
            .finish();
        Ok(())
    }
}
pub struct PVTLayerArgs<'a> {
    pub name: u32,
    pub features: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTFeature<'a>>>,
        >,
    >,
}
impl<'a> Default for PVTLayerArgs<'a> {
    #[inline]
    fn default() -> Self {
        PVTLayerArgs {
            name: 0,
            features: None,
        }
    }
}

pub struct PVTLayerBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PVTLayerBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: u32) {
        self.fbb_.push_slot::<u32>(PVTLayer::VT_NAME, name, 0);
    }
    #[inline]
    pub fn add_features(
        &mut self,
        features: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PVTFeature<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PVTLayer::VT_FEATURES, features);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PVTLayerBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PVTLayerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PVTLayer<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PVTLayer<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PVTLayer");
        ds.field("name", &self.name());
        ds.field("features", &self.features());
        ds.finish()
    }
}
pub enum PVTFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PVTFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PVTFeature<'a> {
    type Inner = PVTFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PVTFeature<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_H: flatbuffers::VOffsetT = 6;
    pub const VT_KEYS: flatbuffers::VOffsetT = 8;
    pub const VT_VALUES: flatbuffers::VOffsetT = 10;
    pub const VT_GEOMETRIES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PVTFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PVTFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<PVTFeature<'bldr>> {
        let mut builder = PVTFeatureBuilder::new(_fbb);
        builder.add_h(args.h);
        builder.add_id(args.id);
        if let Some(x) = args.geometries {
            builder.add_geometries(x);
        }
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        if let Some(x) = args.keys {
            builder.add_keys(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(PVTFeature::VT_ID, Some(0)).unwrap() }
    }
    #[inline]
    pub fn h(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(PVTFeature::VT_H, Some(0)).unwrap() }
    }
    #[inline]
    pub fn keys(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    PVTFeature::VT_KEYS,
                    None,
                )
        }
    }
    #[inline]
    pub fn values(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    PVTFeature::VT_VALUES,
                    None,
                )
        }
    }
    #[inline]
    pub fn geometries(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTGeometry<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTGeometry>>,
            >>(PVTFeature::VT_GEOMETRIES, None)
        }
    }
}

impl flatbuffers::Verifiable for PVTFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("id", Self::VT_ID, false)?
            .visit_field::<u64>("h", Self::VT_H, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "keys",
                Self::VT_KEYS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "values",
                Self::VT_VALUES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PVTGeometry>>,
            >>("geometries", Self::VT_GEOMETRIES, false)?
            .finish();
        Ok(())
    }
}
pub struct PVTFeatureArgs<'a> {
    pub id: u64,
    pub h: u64,
    pub keys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub geometries: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PVTGeometry<'a>>>,
        >,
    >,
}
impl<'a> Default for PVTFeatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        PVTFeatureArgs {
            id: 0,
            h: 0,
            keys: None,
            values: None,
            geometries: None,
        }
    }
}

pub struct PVTFeatureBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PVTFeatureBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: u64) {
        self.fbb_.push_slot::<u64>(PVTFeature::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_h(&mut self, h: u64) {
        self.fbb_.push_slot::<u64>(PVTFeature::VT_H, h, 0);
    }
    #[inline]
    pub fn add_keys(&mut self, keys: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PVTFeature::VT_KEYS, keys);
    }
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PVTFeature::VT_VALUES, values);
    }
    #[inline]
    pub fn add_geometries(
        &mut self,
        geometries: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PVTGeometry<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PVTFeature::VT_GEOMETRIES, geometries);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PVTFeatureBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PVTFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PVTFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PVTFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PVTFeature");
        ds.field("id", &self.id());
        ds.field("h", &self.h());
        ds.field("keys", &self.keys());
        ds.field("values", &self.values());
        ds.field("geometries", &self.geometries());
        ds.finish()
    }
}
pub enum PVTGeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PVTGeometry<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PVTGeometry<'a> {
    type Inner = PVTGeometry<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PVTGeometry<'a> {
    pub const VT_POINTS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PVTGeometry { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PVTGeometryArgs<'args>,
    ) -> flatbuffers::WIPOffset<PVTGeometry<'bldr>> {
        let mut builder = PVTGeometryBuilder::new(_fbb);
        if let Some(x) = args.points {
            builder.add_points(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn points(&self) -> Option<flatbuffers::Vector<'a, PVTTilePoint>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, PVTTilePoint>>>(
                    PVTGeometry::VT_POINTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for PVTGeometry<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, PVTTilePoint>>>(
                "points",
                Self::VT_POINTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct PVTGeometryArgs<'a> {
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, PVTTilePoint>>>,
}
impl<'a> Default for PVTGeometryArgs<'a> {
    #[inline]
    fn default() -> Self {
        PVTGeometryArgs { points: None }
    }
}

pub struct PVTGeometryBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PVTGeometryBuilder<'a, 'b> {
    #[inline]
    pub fn add_points(
        &mut self,
        points: flatbuffers::WIPOffset<flatbuffers::Vector<'b, PVTTilePoint>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PVTGeometry::VT_POINTS, points);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PVTGeometryBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PVTGeometryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PVTGeometry<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PVTGeometry<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PVTGeometry");
        ds.field("points", &self.points());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PVTTile`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_pvttile_unchecked`.
pub fn root_as_pvttile(buf: &[u8]) -> Result<PVTTile, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<PVTTile>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PVTTile` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_pvttile_unchecked`.
pub fn size_prefixed_root_as_pvttile(
    buf: &[u8],
) -> Result<PVTTile, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<PVTTile>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PVTTile` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_pvttile_unchecked`.
pub fn root_as_pvttile_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<PVTTile<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<PVTTile<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PVTTile` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_pvttile_unchecked`.
pub fn size_prefixed_root_as_pvttile_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<PVTTile<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<PVTTile<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PVTTile and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PVTTile`.
pub unsafe fn root_as_pvttile_unchecked(buf: &[u8]) -> PVTTile {
    flatbuffers::root_unchecked::<PVTTile>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PVTTile and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PVTTile`.
pub unsafe fn size_prefixed_root_as_pvttile_unchecked(buf: &[u8]) -> PVTTile {
    flatbuffers::size_prefixed_root_unchecked::<PVTTile>(buf)
}
#[inline]
pub fn finish_pvttile_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<PVTTile<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_pvttile_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<PVTTile<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
